---
phase: 02-quebec-domain-logic
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/compteqc/quebec/__init__.py
  - src/compteqc/quebec/rates.py
  - src/compteqc/quebec/paie/__init__.py
  - src/compteqc/quebec/paie/cotisations.py
  - src/compteqc/quebec/paie/ytd.py
  - ledger/comptes.beancount
  - tests/test_rates.py
  - tests/test_cotisations.py
autonomous: true
requirements: [PAY-02, PAY-03, PAY-04, PAY-05, PAY-06, PAY-07, PAY-10, PAY-12]

must_haves:
  truths:
    - "All 2026 payroll rates (QPP, RQAP, EI, FSS, CNESST, labour standards, tax brackets, personal amounts) are accessible via obtenir_taux(2026)"
    - "QPP base, additional 1, and additional 2 are calculated with correct rates, separate maximums, and proper exemption handling"
    - "RQAP employer/employee, EI employer/employee, FSS, CNESST, and labour standards are each calculated correctly with their respective caps"
    - "YTD tracking derives cumulative contributions from existing ledger transactions and stops contributions at annual maximums"
    - "Payroll liability sub-accounts exist in the chart of accounts for per-deduction-type YTD queries"
  artifacts:
    - path: "src/compteqc/quebec/rates.py"
      provides: "All 2026 rates, thresholds, maximums, tax brackets as frozen dataclasses"
      contains: "TauxAnnuels"
    - path: "src/compteqc/quebec/paie/cotisations.py"
      provides: "Pure Decimal calculation functions for all 7 contribution types"
      contains: "calculer_qpp_base"
    - path: "src/compteqc/quebec/paie/ytd.py"
      provides: "YTD accumulation from ledger for contribution cap enforcement"
      contains: "obtenir_cumuls_annuels"
    - path: "tests/test_cotisations.py"
      provides: "Comprehensive tests with known-good values for every contribution"
      min_lines: 100
  key_links:
    - from: "src/compteqc/quebec/paie/cotisations.py"
      to: "src/compteqc/quebec/rates.py"
      via: "obtenir_taux(annee) for all rate lookups"
      pattern: "obtenir_taux"
    - from: "src/compteqc/quebec/paie/cotisations.py"
      to: "src/compteqc/quebec/paie/ytd.py"
      via: "YTD cumul passed as argument to cap contributions"
      pattern: "cumul_annuel"
---

<objective>
Implement the centralized rate configuration and all payroll contribution calculations (QPP three-tier, RQAP, EI Quebec rate, FSS, CNESST, labour standards) with YTD tracking for annual maximum enforcement.

Purpose: These are the foundational calculation functions that the payroll engine (Plan 02-02) orchestrates. Every number must be Decimal, every rate must come from rates.py, and every contribution must respect annual maximums via YTD tracking. This is the highest-value, highest-risk module in the phase.

Output: Tested pure-function contribution calculators, centralized rate config, and YTD tracking module.
</objective>

<execution_context>
@/Users/philippebeliveau/.claude/get-shit-done/workflows/execute-plan.md
@/Users/philippebeliveau/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-quebec-domain-logic/02-RESEARCH.md
@.planning/phases/01-ledger-foundation-and-import-pipeline/01-01-SUMMARY.md
@ledger/comptes.beancount
</context>

<tasks>

<task type="auto">
  <name>Task 1: Creer rates.py avec tous les taux 2026 et mettre a jour le plan comptable pour les sous-comptes de paie</name>
  <files>
    src/compteqc/quebec/__init__.py
    src/compteqc/quebec/rates.py
    src/compteqc/quebec/paie/__init__.py
    ledger/comptes.beancount
    tests/test_rates.py
  </files>
  <action>
Create the quebec module structure and the centralized rate configuration.

**1. Create module structure:**
- `src/compteqc/quebec/__init__.py` — empty
- `src/compteqc/quebec/paie/__init__.py` — empty

**2. Create `src/compteqc/quebec/rates.py`** with ALL 2026 rates as frozen dataclasses:
- `TauxQPP`: base 5.3%, additional_1 1.0%, additional_2 4.0%, exemption $3,500, MGA $74,600, MGAP $85,000, max_base $3,768.30, max_supp1 $711.00, max_supp2 $416.00
- `TauxRQAP`: employer 0.602%, employee 0.430%, MRA $103,000, max_employer $620.06, max_employee $442.90
- `TauxAE`: employee 1.30%, employer 1.82%, MRA $68,900, max_employee $895.70, max_employer $1,253.98
- `TauxFSS`: service_petite 1.65%, seuil $1,000,000
- `TrancheFederale` and `TrancheQuebec` with `seuil`, `taux`, `constante`
- `TauxAnnuels` aggregating all of the above plus: cnesst_taux (default 0.80%), normes_travail 0.06%, normes_travail_max $103,000, federal brackets (14%/20.5%/26%/29%/33% with correct K constants), Quebec brackets (14%/19%/24%/25.75% with correct constants), montant_personnel_federal $16,452, montant_personnel_quebec $18,952, abattement_quebec 16.5%, tps 5%, tvq 9.975%
- `TAUX_2026` instance and `TAUX = {2026: TAUX_2026}` registry
- `obtenir_taux(annee: int) -> TauxAnnuels` function
- ALL values as `Decimal` — never float. Use the exact values from the research doc.
- Federal brackets for 2026 (lowest rate is 14%, NOT 15%): ($58,523, 14%, K=0), ($117,045, 20.5%, K=$3,804), ($181,440, 26%, K=$10,237), ($258,482, 29%, K=$15,680), (inf, 33%, K=$26,019)
- Quebec brackets: ($54,345, 14%, K=0), ($108,680, 19%, K=$2,717), ($132,245, 24%, K=$5,151), (inf, 25.75%, K=$7,465)

**3. Update `ledger/comptes.beancount`** — expand payroll liability accounts per Discretion Recommendation #3 from research. Replace single `Passifs:Retenues-A-Payer` with specific sub-accounts to enable trivial YTD queries:
- `Passifs:Retenues:QPP-Base` (gifi: "2620")
- `Passifs:Retenues:QPP-Supp1` (gifi: "2620")
- `Passifs:Retenues:QPP-Supp2` (gifi: "2620")
- `Passifs:Retenues:RQAP` (gifi: "2620")
- `Passifs:Retenues:AE` (gifi: "2620")
- `Passifs:Retenues:Impot-Federal` (gifi: "2620")
- `Passifs:Retenues:Impot-Quebec` (gifi: "2620")
Keep the old `Passifs:Retenues-A-Payer` for backward compatibility (existing transactions may use it). Also expand `Passifs:Cotisations-Employeur` into:
- `Passifs:Cotisations-Employeur:QPP` (gifi: "2620")
- `Passifs:Cotisations-Employeur:RQAP` (gifi: "2620")
- `Passifs:Cotisations-Employeur:AE` (gifi: "2620")
- `Passifs:Cotisations-Employeur:FSS` (gifi: "2620")
- `Passifs:Cotisations-Employeur:CNESST` (gifi: "2620")
- `Passifs:Cotisations-Employeur:Normes-Travail` (gifi: "2620")
Keep original `Passifs:Cotisations-Employeur` for backward compat.
Run `bean-check ledger/main.beancount` to verify the chart of accounts is valid after changes.

**4. Create `tests/test_rates.py`:**
- Test `obtenir_taux(2026)` returns correct TauxAnnuels
- Test `obtenir_taux(2025)` raises ValueError
- Spot-check key values: QPP base rate = 0.053, federal lowest rate = 0.14 (NOT 0.15), EI employee rate = 0.013
- Verify all tax bracket lists are populated and correctly ordered
  </action>
  <verify>
    `uv run pytest tests/test_rates.py -v` — all tests pass.
    `uv run bean-check ledger/main.beancount` — 0 errors (chart of accounts valid with new sub-accounts).
    `uv run python -c "from compteqc.quebec.rates import obtenir_taux; t = obtenir_taux(2026); print(t.qpp.taux_base, t.tranches_federales[0].taux)"` prints `0.053 0.14`.
  </verify>
  <done>
    rates.py contains all 2026 rates as frozen Decimal dataclasses, obtenir_taux(2026) works, comptes.beancount has per-deduction-type liability sub-accounts, bean-check passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implementer les fonctions de calcul de cotisations et le suivi cumul annuel (TDD)</name>
  <files>
    src/compteqc/quebec/paie/cotisations.py
    src/compteqc/quebec/paie/ytd.py
    tests/test_cotisations.py
  </files>
  <action>
TDD: Write tests FIRST, then implement.

**RED phase — Create `tests/test_cotisations.py` with failing tests:**

Test each contribution function with known-good values. Use annual salary of $60,000 (bi-weekly = $2,307.69, 26 periods) as the primary test case:

- `test_qpp_base_employe` — QPP base: gains_cotisables = min($2,307.69, $74,600/26) - $3,500/26 = $2,307.69 - $134.62 = $2,173.07. Cotisation = $2,173.07 * 0.053 = $115.17. Also test: YTD at $3,700 with only $68.30 remaining (cap test).
- `test_qpp_supplementaire1_employe` — Same earnings range as base, rate 1.0%, separate max $711.00.
- `test_qpp_supplementaire2_employe` — Only on earnings $74,600-$85,000. For $60K salary: $0 (below MGA). For $90K salary (bi-weekly $3,461.54): gains = min($3,461.54, $85,000/26) - max($74,600/26, $3,461.54) ... calculate correctly.
- `test_rqap_employe` and `test_rqap_employeur` — $2,307.69 * 0.00430 = $9.92 (employee). Employer: $2,307.69 * 0.00602 = $13.89.
- `test_ae_employe` and `test_ae_employeur` — $2,307.69 * 0.0130 = $30.00. Employer: $2,307.69 * 0.0182 = $42.00.
- `test_fss` — $60,000 * 0.0165 = $990.00 annually. Per period: $990.00 / 26 = $38.08.
- `test_cnesst` — $2,307.69 * 0.0080 = $18.46.
- `test_normes_travail` — $2,307.69 * 0.0006 = $1.38.
- `test_ytd_cap_qpp_base` — When YTD is at $3,700, remaining = $68.30, so next contribution = min(calculated, $68.30).
- `test_ytd_cap_ei` — When YTD employer is at $1,200, remaining = $53.98.
- `test_zero_when_maximum_reached` — When YTD equals or exceeds max, return Decimal("0").

**GREEN phase — Create `src/compteqc/quebec/paie/cotisations.py`:**

Pure functions using Decimal math exclusively. Each function signature:
```python
def calculer_qpp_base_employe(salaire_brut_periode: Decimal, cumul_annuel: Decimal, taux: TauxQPP, nb_periodes: int) -> Decimal
def calculer_qpp_supp1_employe(salaire_brut_periode: Decimal, cumul_annuel: Decimal, taux: TauxQPP, nb_periodes: int) -> Decimal
def calculer_qpp_supp2_employe(salaire_brut_periode: Decimal, cumul_annuel: Decimal, taux: TauxQPP, nb_periodes: int) -> Decimal
def calculer_rqap_employe(salaire_brut_periode: Decimal, cumul_annuel: Decimal, taux: TauxRQAP, nb_periodes: int) -> Decimal
def calculer_rqap_employeur(salaire_brut_periode: Decimal, cumul_annuel: Decimal, taux: TauxRQAP, nb_periodes: int) -> Decimal
def calculer_ae_employe(salaire_brut_periode: Decimal, cumul_annuel: Decimal, taux: TauxAE, nb_periodes: int) -> Decimal
def calculer_ae_employeur(salaire_brut_periode: Decimal, cumul_annuel: Decimal, taux: TauxAE, nb_periodes: int) -> Decimal
def calculer_fss(masse_salariale_annuelle: Decimal, taux: TauxFSS, nb_periodes: int) -> Decimal
def calculer_cnesst(salaire_brut_periode: Decimal, taux_cnesst: Decimal) -> Decimal
def calculer_normes_travail(salaire_brut_periode: Decimal, cumul_annuel_gains: Decimal, taux: Decimal, max_gains: Decimal) -> Decimal
```

Key implementation details:
- QPP base: deduct per-period exemption ($3,500/nb_periodes), cap at per-period MGA ($74,600/nb_periodes), apply 5.3%, cap at annual max minus YTD
- QPP supp1: same earnings range as base (but NO exemption deducted — the exemption only applies to base), rate 1.0%, separate max $711.00
- QPP supp2: earnings between MGA and MGAP only ($74,600-$85,000), rate 4.0%, max $416.00
- All rounding: `Decimal.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)`
- FSS: employer-only, annual calculation divided by nb_periodes (per Pitfall #6 from research — but for per-period accrual, divide annual estimate)
- CNESST: no annual max (based on insurable earnings up to MRA), simple rate * salary

**Create `src/compteqc/quebec/paie/ytd.py`:**

Function `obtenir_cumuls_annuels(chemin_ledger: str, annee: int) -> dict[str, Decimal]` that:
- Loads the beancount ledger via `beancount.loader.load_file`
- Filters transactions with tag `paie` in the given year
- Sums postings by sub-account to derive YTD for each contribution type
- Returns dict with keys like `"qpp_base_employe"`, `"qpp_supp1_employe"`, `"rqap_employe"`, `"ae_employe"`, etc.
- Uses the new sub-accounts: `Passifs:Retenues:QPP-Base`, `Passifs:Retenues:QPP-Supp1`, etc.
- Returns Decimal("0") for all keys if no paie transactions exist yet (first payroll of year)

Also provide `calculer_cumuls_depuis_transactions(entries: list, annee: int) -> dict[str, Decimal]` for testability (doesn't require file I/O).
  </action>
  <verify>
    `uv run pytest tests/test_cotisations.py -v` — all tests pass.
    `uv run python -c "from compteqc.quebec.paie.cotisations import calculer_qpp_base_employe; from decimal import Decimal; from compteqc.quebec.rates import obtenir_taux; t = obtenir_taux(2026); print(calculer_qpp_base_employe(Decimal('2307.69'), Decimal('0'), t.qpp, 26))"` — prints a reasonable QPP base amount (~$115).
  </verify>
  <done>
    All 7 contribution types have tested pure-function calculators. YTD tracking derives cumuls from ledger. Annual maximums are enforced (contributions return 0 when cap reached). All math uses Decimal with ROUND_HALF_UP. QPP base and additional are tracked separately with independent maximums.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_rates.py tests/test_cotisations.py -v` — all pass
2. `uv run bean-check ledger/main.beancount` — 0 errors
3. `uv run ruff check src/compteqc/quebec/` — no lint errors
4. Verify: no `float` literals in rates.py or cotisations.py (only Decimal)
5. Verify: rates.py has no hardcoded rates in calculation functions (all from obtenir_taux)
</verification>

<success_criteria>
- obtenir_taux(2026) returns all rates as Decimal values matching official 2026 sources
- Each of the 7 contribution types calculates correctly for a standard bi-weekly pay period
- YTD caps work: when cumul_annuel approaches the maximum, the function returns only the remaining amount
- When cumul_annuel >= maximum, the function returns Decimal("0")
- Chart of accounts has per-deduction sub-accounts for clean YTD queries
- All tests pass, no float anywhere in the module
</success_criteria>

<output>
After completion, create `.planning/phases/02-quebec-domain-logic/02-01-SUMMARY.md`
</output>
