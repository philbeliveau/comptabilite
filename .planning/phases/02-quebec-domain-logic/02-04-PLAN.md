---
phase: 02-quebec-domain-logic
plan: 04
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/compteqc/quebec/dpa/__init__.py
  - src/compteqc/quebec/dpa/classes.py
  - src/compteqc/quebec/dpa/registre.py
  - src/compteqc/quebec/dpa/calcul.py
  - src/compteqc/quebec/dpa/journal.py
  - src/compteqc/quebec/pret_actionnaire/__init__.py
  - src/compteqc/quebec/pret_actionnaire/suivi.py
  - src/compteqc/quebec/pret_actionnaire/alertes.py
  - src/compteqc/quebec/pret_actionnaire/detection.py
  - tests/test_dpa.py
  - tests/test_pret_actionnaire.py
  - data/actifs.yaml
autonomous: true
requirements: [CCA-01, CCA-02, CCA-03, CCA-04, CCA-05, CCA-06, LOAN-01, LOAN-02, LOAN-03, LOAN-04]

must_haves:
  truths:
    - "Capital assets are tracked by CCA class (8, 10, 12, 50, 54) with pool-level UCC"
    - "Half-year rule is automatically applied to net additions in the first year"
    - "Declining balance CCA is calculated per class at correct rates and generates Beancount transactions flagged with ! for review"
    - "Asset disposals trigger recapture or terminal loss calculations"
    - "Shareholder loan tracks bidirectional balance (positive = shareholder owes corp)"
    - "s.15(2) deadline alerts fire at 9 months, 11 months, and 30 days before inclusion date"
    - "Circular loan-repayment-reborrow patterns within 30 days are flagged"
  artifacts:
    - path: "src/compteqc/quebec/dpa/calcul.py"
      provides: "Pool-level CCA calculation with half-year rule and declining balance"
      contains: "calculer_dpa"
    - path: "src/compteqc/quebec/dpa/registre.py"
      provides: "Asset registry and pool-level UCC tracking"
      contains: "RegistreActifs"
    - path: "src/compteqc/quebec/dpa/journal.py"
      provides: "CCA Beancount transaction generation"
      contains: "generer_transactions_dpa"
    - path: "src/compteqc/quebec/pret_actionnaire/alertes.py"
      provides: "s.15(2) deadline calculation and graduated alerts"
      contains: "calculer_dates_alerte"
    - path: "src/compteqc/quebec/pret_actionnaire/detection.py"
      provides: "Circular loan pattern detection"
      contains: "detecter_circularite"
    - path: "data/actifs.yaml"
      provides: "Persistent asset registry for CCA tracking"
      contains: "actifs"
    - path: "tests/test_dpa.py"
      provides: "CCA calculation tests including half-year, disposal, recapture"
      min_lines: 80
    - path: "tests/test_pret_actionnaire.py"
      provides: "Shareholder loan tests including deadline and circularity"
      min_lines: 60
  key_links:
    - from: "src/compteqc/quebec/dpa/calcul.py"
      to: "src/compteqc/quebec/dpa/registre.py"
      via: "reads asset pools for CCA calculation"
      pattern: "RegistreActifs|PoolDPA"
    - from: "src/compteqc/quebec/dpa/journal.py"
      to: "beancount.core.data"
      via: "creates depreciation transactions"
      pattern: "data\\.Transaction|create_simple_posting"
    - from: "src/compteqc/quebec/pret_actionnaire/alertes.py"
      to: "datetime"
      via: "deadline date arithmetic using relativedelta"
      pattern: "relativedelta"
---

<objective>
Implement CCA (capital cost allowance) asset tracking with pool-level depreciation and shareholder loan monitoring with s.15(2) deadline alerts.

Purpose: CCA tracks the tax depreciation of capital assets (computers, furniture, etc.) and generates year-end entries. The shareholder loan module monitors personal-vs-business transactions and alerts before s.15(2) inclusion dates to prevent accidental taxable benefits. Both are critical for CPA year-end review.

Output: CCA asset registry with depreciation calculations and Beancount entries, shareholder loan tracker with deadline alerts and circularity detection.

NOTE — Architectural decision re: locked decision "auto-detect personal transactions and flag for confirmation / never silently post":
This constraint is enforced at the transaction categorization stage (Phase 1 rule engine + Phase 3 AI classification), NOT at the shareholder loan tracking stage. Plan 02-04's `suivi.py` reads the ledger passively to compute loan state from already-posted transactions. The "never silently post" guarantee is the responsibility of the ingestion/categorization pipeline, which must flag ambiguous personal-vs-business transactions for human confirmation before they are posted to the ledger. The shareholder loan module then accurately tracks whatever has been approved and posted.
</objective>

<execution_context>
@/Users/philippebeliveau/.claude/get-shit-done/workflows/execute-plan.md
@/Users/philippebeliveau/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-quebec-domain-logic/02-RESEARCH.md
@.planning/phases/01-ledger-foundation-and-import-pipeline/01-01-SUMMARY.md
@ledger/comptes.beancount
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implementer le registre d'actifs, le calcul DPA par pool, et la generation de transactions Beancount</name>
  <files>
    src/compteqc/quebec/dpa/__init__.py
    src/compteqc/quebec/dpa/classes.py
    src/compteqc/quebec/dpa/registre.py
    src/compteqc/quebec/dpa/calcul.py
    src/compteqc/quebec/dpa/journal.py
    data/actifs.yaml
    tests/test_dpa.py
  </files>
  <action>
**1. Create `src/compteqc/quebec/dpa/classes.py`** — CCA class definitions:

```python
CLASSES_DPA = {
    8: {"taux": Decimal("0.20"), "description": "Mobilier et equipement de bureau"},
    10: {"taux": Decimal("0.30"), "description": "Vehicules automobiles"},
    12: {"taux": Decimal("1.00"), "description": "Logiciels, outils < $500"},
    50: {"taux": Decimal("0.55"), "description": "Materiel informatique (ordinateurs, moniteurs)"},
    54: {"taux": Decimal("0.30"), "description": "Vehicules zero emission"},
}
```

**2. Create `src/compteqc/quebec/dpa/registre.py`** — Asset registry:

Define Pydantic models:
```python
class Actif(BaseModel):
    id: str                     # Unique identifier (e.g., "mac-studio-2026")
    description: str            # "Mac Studio M4 Ultra"
    classe: int                 # CCA class (8, 10, 12, 50, 54)
    cout: Decimal               # Original cost
    date_acquisition: date      # Date purchased
    date_disposition: date | None = None  # Date sold/disposed (None if still held)
    produit_disposition: Decimal | None = None  # Proceeds of disposition

class RegistreActifs:
    """Manages asset registry persisted in data/actifs.yaml"""
    def charger(self, chemin: str = "data/actifs.yaml") -> list[Actif]
    def sauvegarder(self, actifs: list[Actif], chemin: str = "data/actifs.yaml")
    def ajouter(self, actif: Actif)
    def disposer(self, id_actif: str, date: date, produit: Decimal)
    def actifs_par_classe(self, annee: int) -> dict[int, list[Actif]]
```

**3. Create `data/actifs.yaml`** — empty initial registry:
```yaml
# Registre des actifs immobilises pour le calcul de la DPA
# Ajouter les actifs via: cqc dpa ajouter <description> <cout> <classe>
actifs: []
```

**4. Create `src/compteqc/quebec/dpa/calcul.py`** — Pool-level CCA:

```python
@dataclass
class PoolDPA:
    classe: int
    taux: Decimal
    ucc_ouverture: Decimal      # Opening UCC from prior year
    acquisitions: Decimal        # This year's acquisitions
    dispositions: Decimal        # This year's dispositions (lesser of cost or proceeds)

    @property
    def additions_nettes(self) -> Decimal
    def calculer_dpa(self) -> Decimal  # With half-year rule on positive net additions
    @property
    def ucc_fermeture(self) -> Decimal
    @property
    def recapture(self) -> Decimal  # If UCC after dispositions < 0
    def perte_finale(self, nb_actifs_restants: int) -> Decimal  # If class empty and UCC > 0

def construire_pools(
    actifs: list[Actif],
    ucc_precedent: dict[int, Decimal],  # Opening UCCs from prior year
    annee: int,
) -> dict[int, PoolDPA]:
    """Build CCA pools for the year from asset registry and prior-year UCCs."""
```

Half-year rule: if `additions_nettes > 0`, CCA base = `ucc_ouverture + (additions_nettes * 0.5)`. Otherwise, CCA base = `ucc_ouverture + additions_nettes`.

Disposition amount = `min(cout_original, produit_disposition)` per CRA rules.

Recapture: if `ucc_ouverture - dispositions < 0` (pool goes negative), recapture = abs(negative amount). Added to income.

Terminal loss: if pool has no remaining assets AND `ucc_fermeture > 0`, the remaining UCC is a deductible terminal loss.

**5. Create `src/compteqc/quebec/dpa/journal.py`** — Beancount entries:

```python
def generer_transactions_dpa(
    pools: dict[int, PoolDPA],
    date_fin_exercice: date,
) -> list[data.Transaction]:
    """Generate one Beancount transaction per CCA class.
    Each transaction:
    - Dr Depenses:Amortissement (CCA amount)
    - Cr Actifs:Immobilisations:Amortissement-Cumule (CCA amount)
    Flag '!' (needs review) per discretion recommendation.
    Metadata: classe, taux, ucc_ouverture, ucc_fermeture.
    Also generates recapture/terminal loss transactions if applicable."""
```

Flag `!` (needs review) per Discretion Recommendation #2 from research: CCA is discretionary, auto-generate with review.

**6. Create `tests/test_dpa.py`:**

- `test_dpa_classe_50_premiere_annee`: Acquire $3,000 computer. UCC opening = 0. Additions = $3,000. Half-year: base = 0 + (3000 * 0.5) = $1,500. CCA = $1,500 * 0.55 = $825.00. UCC closing = $3,000 - $825 = $2,175.
- `test_dpa_classe_50_deuxieme_annee`: UCC opening = $2,175. No new acquisitions. CCA = $2,175 * 0.55 = $1,196.25. UCC closing = $978.75.
- `test_dpa_demi_taux_additions_nettes`: Year with both $3,000 acquisition and $1,000 disposition (cost $1,500, proceeds $1,000, disposition amount = min($1,500, $1,000) = $1,000). Net additions = $3,000 - $1,000 = $2,000. Half-year on $2,000.
- `test_recapture`: UCC opening = $500, disposition amount = $800. UCC goes negative by $300 → recapture $300.
- `test_perte_finale`: UCC opening = $200, all assets disposed at $0, no assets remain → terminal loss $200.
- `test_registre_ajouter_et_charger`: Round-trip YAML persistence.
- `test_journal_dpa_flag_review`: Generated transaction has `!` flag.
  </action>
  <verify>
    `uv run pytest tests/test_dpa.py -v` — all tests pass.
    `uv run ruff check src/compteqc/quebec/dpa/` — no lint errors.
  </verify>
  <done>
    CCA pool-level calculation works for all 5 classes with half-year rule on net additions, declining balance depreciation, recapture, and terminal loss. Asset registry persists to YAML. Beancount transactions generated with `!` flag for CPA review. All amounts are Decimal.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implementer le suivi du pret actionnaire avec alertes s.15(2) et detection de circularite</name>
  <files>
    src/compteqc/quebec/pret_actionnaire/__init__.py
    src/compteqc/quebec/pret_actionnaire/suivi.py
    src/compteqc/quebec/pret_actionnaire/alertes.py
    src/compteqc/quebec/pret_actionnaire/detection.py
    tests/test_pret_actionnaire.py
  </files>
  <action>
**1. Create `src/compteqc/quebec/pret_actionnaire/suivi.py`** — Loan tracking:

```python
@dataclass
class MouvementPret:
    date: datetime.date
    montant: Decimal          # Positive = shareholder owes more, negative = repayment
    description: str
    type: str                 # "avance", "remboursement", "salaire_offset", "depot_personnel"

@dataclass
class EtatPret:
    solde: Decimal            # Positive = shareholder owes corp, negative = corp owes shareholder
    mouvements: list[MouvementPret]
    avances_ouvertes: list[dict]  # Advances with their s.15(2) deadlines

def obtenir_etat_pret(
    entries: list,  # Beancount entries
    fin_exercice: datetime.date,
) -> EtatPret:
    """Extract shareholder loan state from ledger.
    Reads postings to Passifs:Pret-Actionnaire.
    Positive posting = shareholder borrows (owes more).
    Negative posting = repayment.
    Tracks each advance separately for s.15(2) deadline calculation."""
```

Bidirectional tracking per user decision: positive = shareholder owes corp, negative = corp owes shareholder. Single net balance, but full detail of every movement preserved.

**2. Create `src/compteqc/quebec/pret_actionnaire/alertes.py`** — s.15(2) deadlines:

```python
@dataclass
class AlertePret:
    date_avance: datetime.date
    montant: Decimal
    date_inclusion: datetime.date     # Fiscal year-end + 1 year
    alerte_9_mois: datetime.date
    alerte_11_mois: datetime.date
    alerte_30_jours: datetime.date
    solde_restant: Decimal            # How much of this advance is still outstanding

def calculer_dates_alerte(
    date_avance: datetime.date,
    montant: Decimal,
    fin_exercice: datetime.date,
) -> AlertePret:
    """Calculate s.15(2) alert dates for a shareholder loan advance.
    Inclusion date = fiscal year-end containing the advance + 1 year.
    For Dec 31 FYE: any advance in 2026 → inclusion Dec 31, 2027.
    Alert dates: inclusion - 9 months, inclusion - 11 months, inclusion - 30 days."""

def obtenir_alertes_actives(
    etat: EtatPret,
    date_courante: datetime.date,
) -> list[dict]:
    """Return list of active alerts (past alert dates that haven't been cleared).
    Each alert: {avance, montant, deadline, urgence: '9_mois'|'11_mois'|'30_jours'|'depasse'}
    Only returns alerts for advances with remaining balance > 0."""
```

Use `python-dateutil` `relativedelta` for month arithmetic (per Don't Hand-Roll from research). Install if not already available: `from dateutil.relativedelta import relativedelta`.

Critical detail (Pitfall #4 from research): The deadline is relative to fiscal year-end, NOT the loan date. For Dec 31 FYE, any loan in 2026 has inclusion date Dec 31, 2027.

**3. Create `src/compteqc/quebec/pret_actionnaire/detection.py`** — Circularity detection:

```python
def detecter_circularite(
    mouvements: list[MouvementPret],
    fenetre_jours: int = 30,
) -> list[dict]:
    """Detect potential circular loan-repayment-reborrow patterns per s.15(2.6).
    Flags if a repayment is followed by a new advance of similar amount
    (within 20% tolerance) within the specified window (default 30 days).
    Returns: [{date_remboursement, montant_remboursement, date_avance, montant_avance, ecart_jours}]"""
```

**4. Create `tests/test_pret_actionnaire.py`:**

- `test_calculer_dates_alerte_dec31`: Advance June 15, 2026, FYE Dec 31 → inclusion Dec 31, 2027. Alert 9 months = Mar 31, 2027. Alert 11 months = Jan 31, 2027. Alert 30 jours = Dec 1, 2027.
- `test_calculer_dates_alerte_avance_janvier`: Advance Jan 5, 2026 → same inclusion Dec 31, 2027 (NOT Jan 5, 2027).
- `test_solde_bidirectionnel`: Advance $5,000, repayment $3,000 → balance $2,000 (positive, shareholder owes).
- `test_solde_negatif`: Corp owes shareholder $1,000 → balance -$1,000.
- `test_alertes_actives_9_mois`: Set current date to April 2027 (past 9-month mark) → alert returned with urgence "9_mois".
- `test_alertes_actives_depasse`: Set current date to Jan 2028 (past inclusion) → alert with urgence "depasse".
- `test_alertes_cleared_advance`: Advance fully repaid → no alert.
- `test_circularite_detectee`: Repay $5,000 on Jan 15, new advance $4,800 on Feb 1 (17 days, within 20% of amount) → flagged.
- `test_circularite_ok`: Repay $5,000 on Jan 15, new advance $1,000 on June 1 → not flagged (different amount and outside window).
- `test_pas_de_circularite_montant_different`: Repay $5,000, borrow $500 (not within 20%) → not flagged.

Use `freezegun` for date mocking in alert tests: `@freeze_time("2027-04-15")`.

Add `python-dateutil` and `freezegun` as dependencies if not already in pyproject.toml:
```bash
uv add python-dateutil
uv add --dev freezegun
```
  </action>
  <verify>
    `uv run pytest tests/test_pret_actionnaire.py -v` — all tests pass.
    `uv run pytest tests/test_dpa.py tests/test_pret_actionnaire.py -v` — all pass together.
    `uv run ruff check src/compteqc/quebec/pret_actionnaire/ src/compteqc/quebec/dpa/` — no lint errors.
  </verify>
  <done>
    CCA and shareholder loan modules complete. CCA: pool-level tracking for 5 classes, half-year rule, declining balance, recapture/terminal loss, Beancount entries with `!` flag. Shareholder loan: bidirectional balance tracking, s.15(2) deadline calculation based on fiscal year-end (not loan date), graduated alerts at 9/11 months and 30 days, circular pattern detection. All tested with freezegun for date-dependent tests.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_dpa.py tests/test_pret_actionnaire.py -v` — all pass
2. `uv run ruff check src/compteqc/quebec/dpa/ src/compteqc/quebec/pret_actionnaire/` — no lint errors
3. CCA half-year rule: $3,000 computer in class 50 → first year CCA = $825 (not $1,650)
4. Shareholder loan deadline: advance in June 2026 with Dec 31 FYE → inclusion Dec 31, 2027
5. No float literals in any module
</verification>

<success_criteria>
- CCA pools track UCC per class with correct declining balance rates
- Half-year rule applied to net additions (not gross) — Pitfall #5 avoided
- Disposals correctly calculate recapture and terminal loss
- CCA transactions use `!` flag for review (discretionary claim)
- Shareholder loan balance is bidirectional with full movement history
- s.15(2) deadline is fiscal year-end + 1 year (not loan date + 1 year) — Pitfall #4 avoided
- Alerts fire at exactly 9 months, 11 months, and 30 days before inclusion
- Circular patterns flagged within 30-day window with 20% amount tolerance
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-quebec-domain-logic/02-04-SUMMARY.md`
</output>
