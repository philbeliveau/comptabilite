---
phase: 04-mcp-server-and-web-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/compteqc/mcp/__init__.py
  - src/compteqc/mcp/server.py
  - src/compteqc/mcp/services.py
  - src/compteqc/mcp/tools/__init__.py
  - src/compteqc/mcp/tools/ledger.py
  - src/compteqc/mcp/tools/quebec.py
  - tests/test_mcp_server.py
autonomous: true
requirements: [MCP-01, MCP-05, MCP-06]

must_haves:
  truths:
    - "MCP server starts via stdio and responds to tool list requests"
    - "Claude can query account balances with optional filter and get formatted results"
    - "Claude can request trial balance, income statement, and balance sheet reports"
    - "Claude can query GST/QST summary, CCA schedule, and shareholder loan status"
    - "Read-only mode blocks all mutation tools and returns a French error message"
    - "Tool responses are capped at 50 items with a tronque flag for pagination"
  artifacts:
    - path: "src/compteqc/mcp/server.py"
      provides: "FastMCP instance with lifespan AppContext and stdio entry point"
      contains: "FastMCP"
    - path: "src/compteqc/mcp/services.py"
      provides: "Shared service layer for ledger operations"
      exports: ["charger_ledger", "calculer_soldes", "lister_pending"]
    - path: "src/compteqc/mcp/tools/ledger.py"
      provides: "Ledger query tools (soldes_comptes, balance_verification, etat_resultats, bilan)"
      contains: "@mcp.tool"
    - path: "src/compteqc/mcp/tools/quebec.py"
      provides: "Quebec-specific query tools (sommaire_tps_tvq, etat_dpa, etat_pret_actionnaire)"
      contains: "@mcp.tool"
  key_links:
    - from: "src/compteqc/mcp/tools/ledger.py"
      to: "src/compteqc/mcp/services.py"
      via: "import calculer_soldes"
      pattern: "from compteqc.mcp.services import"
    - from: "src/compteqc/mcp/tools/quebec.py"
      to: "src/compteqc/quebec"
      via: "calls existing domain modules"
      pattern: "from compteqc.quebec"
    - from: "src/compteqc/mcp/server.py"
      to: "beancount.loader"
      via: "load_file in lifespan"
      pattern: "loader.load_file"
---

<objective>
Create the MCP server core with FastMCP, shared service layer, and all read-only query tools for ledger exploration and Quebec-specific reports.

Purpose: Enables Claude to query the accounting ledger -- balances, trial balance, P&L, balance sheet, GST/QST, CCA, shareholder loan -- via MCP tools. This is the foundation for all MCP interactions.

Output: Working MCP server with 7 query tools, shared service layer, and read-only mode support.
</objective>

<execution_context>
@/Users/philippebeliveau/.claude/get-shit-done/workflows/execute-plan.md
@/Users/philippebeliveau/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-server-and-web-dashboard/04-RESEARCH.md
@.planning/phases/03-ai-categorization-and-review-workflow/03-02-SUMMARY.md

# Key existing modules to wrap:
@src/compteqc/ledger/fichiers.py
@src/compteqc/cli/importer.py
@src/compteqc/quebec/taxes/__init__.py
@src/compteqc/quebec/dpa/__init__.py
@src/compteqc/quebec/pret_actionnaire/__init__.py
@src/compteqc/quebec/paie/ytd.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP server core with FastMCP lifespan and shared service layer</name>
  <files>
    pyproject.toml
    src/compteqc/mcp/__init__.py
    src/compteqc/mcp/server.py
    src/compteqc/mcp/services.py
    src/compteqc/mcp/tools/__init__.py
  </files>
  <action>
    Add `mcp>=1.25,<2` to pyproject.toml dependencies. Pin to v1.x to avoid v2 breaking changes.

    Create `src/compteqc/mcp/server.py`:
    - `AppContext` dataclass with: ledger_path (str), entries (list), errors (list), options (dict), read_only (bool)
    - `AppContext.reload()` method that calls `loader.load_file(self.ledger_path)` to refresh in-memory state after mutations
    - `app_lifespan` async context manager that reads `COMPTEQC_LEDGER` env var (default: "ledger/main.beancount") and `COMPTEQC_READONLY` env var (default: "false")
    - `mcp = FastMCP("CompteQC", lifespan=app_lifespan)` as module-level instance
    - Import tool modules at bottom (compteqc.mcp.tools.ledger, .quebec) with noqa comments
    - `if __name__ == "__main__": mcp.run(transport="stdio")` entry point
    - Also add `__main__.py` or use `-m compteqc.mcp.server` pattern

    Create `src/compteqc/mcp/services.py` (shared service layer for MCP and Fava):
    - `charger_ledger(chemin: str) -> tuple[list, list, dict]` wrapping loader.load_file
    - `calculer_soldes(entries: list, filtre: str | None = None) -> dict[str, Decimal]` computing account balances from Transaction postings (reuse pattern from existing rapports in cli)
    - `lister_pending(entries: list) -> list[dict]` finding #pending transactions with confidence/source metadata
    - `formater_montant(montant: Decimal) -> str` formatting helper for tool responses

    Create `src/compteqc/mcp/__init__.py` and `src/compteqc/mcp/tools/__init__.py` as empty packages.

    Follow the exact FastMCP patterns from 04-RESEARCH.md. Use `Context[ServerSession, AppContext]` type annotation for tool context injection.
  </action>
  <verify>
    Run `uv run python -c "from compteqc.mcp.server import mcp; print(mcp.name)"` prints "CompteQC".
    Run `uv run python -c "from compteqc.mcp.services import calculer_soldes, lister_pending; print('OK')"` succeeds.
  </verify>
  <done>
    FastMCP server instance exists with lifespan context manager, AppContext with reload(), and services.py with calculer_soldes and lister_pending functions. mcp dependency added to pyproject.toml.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ledger and Quebec query tools with read-only mode and tests</name>
  <files>
    src/compteqc/mcp/tools/ledger.py
    src/compteqc/mcp/tools/quebec.py
    tests/test_mcp_server.py
  </files>
  <action>
    Create `src/compteqc/mcp/tools/ledger.py` with 4 tools:
    1. `soldes_comptes(filtre: str | None, ctx)` -- query account balances, optional substring filter, returns {nb_comptes, comptes: [{compte, solde}], tronque}. Cap at 50 items.
    2. `balance_verification(ctx)` -- trial balance showing debits/credits by account class. Return {comptes, total_debits, total_credits, equilibre: bool}.
    3. `etat_resultats(date_debut: str | None, date_fin: str | None, ctx)` -- income statement. Filter entries by date range. Return {revenus: [{compte, montant}], depenses: [{compte, montant}], resultat_net}.
    4. `bilan(ctx)` -- balance sheet. Return {actifs, passifs, capitaux_propres, equilibre: bool}.

    All tools import `mcp` from `compteqc.mcp.server` and use `@mcp.tool()` decorator. All tools access entries via `ctx.request_context.lifespan_context`. All tools call services.py functions for data computation.

    Each tool docstring must be in French (this is what Claude sees as tool description).

    Create `src/compteqc/mcp/tools/quebec.py` with 3 tools:
    1. `sommaire_tps_tvq(periode: str | None, ctx)` -- GST/QST summary. Call existing `compteqc.quebec.taxes` module to compute collected vs ITCs. Return {periode, tps_percue, tvq_percue, tps_payee, tvq_payee, remise_nette_tps, remise_nette_tvq}.
    2. `etat_dpa(annee: int | None, ctx)` -- CCA schedule by class (8, 10, 12, 50, 54). Call existing `compteqc.quebec.dpa` module. Return {annee, classes: [{classe, fnacc_debut, acquisitions, dispositions, dpa_annee, fnacc_fin}]}.
    3. `etat_pret_actionnaire(ctx)` -- shareholder loan status. Call existing `compteqc.quebec.pret_actionnaire` module. Return {solde_net, direction (corp_doit/actionnaire_doit), avances: [...], delai_inclusion_s152, jours_restants, alerte}.

    For s.15(2) deadline, include countdown in days and alert level per existing graduated alert system.

    Create `tests/test_mcp_server.py`:
    - Test that AppContext.reload() refreshes entries
    - Test read-only mode: create AppContext with read_only=True, verify flag is set
    - Test services.py: calculer_soldes with sample Beancount entries
    - Test services.py: lister_pending with #pending tagged entries
    - Test tool response truncation (>50 items produces tronque=True)
    - Use beancount.parser.parse_string to create test entries (no file I/O needed)

    Do NOT test MCP protocol transport -- test the tool functions directly by constructing AppContext and calling the functions.
  </action>
  <verify>
    Run `cd /Users/philippebeliveau/Desktop/Notebook/comptabilite && uv run pytest tests/test_mcp_server.py -v` -- all tests pass.
    Run `uv run python -c "from compteqc.mcp.tools.ledger import soldes_comptes; print('OK')"` succeeds.
  </verify>
  <done>
    7 MCP query tools registered (4 ledger + 3 Quebec), all returning structured dicts with French field names, capped at 50 items with tronque flag. Read-only flag accessible in AppContext. Tests pass covering services layer, truncation, and read-only mode.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "from compteqc.mcp.server import mcp; print(len(mcp._tool_manager._tools))"` shows 7 tools registered
2. `uv run pytest tests/test_mcp_server.py -v` passes all tests
3. `uv run python -m compteqc.mcp.server` starts without error (will hang waiting for stdio input -- Ctrl+C to exit)
4. Read-only flag: verify AppContext(read_only=True) is accessible from tools
</verification>

<success_criteria>
- MCP server starts via stdio with 7 query tools registered
- Shared service layer (services.py) provides calculer_soldes and lister_pending
- All tool responses are structured dicts with French field names
- Read-only mode flag exists and is accessible from tool context
- Tests pass covering core service functions and tool response formatting
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-server-and-web-dashboard/04-01-SUMMARY.md`
</output>
